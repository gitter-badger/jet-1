### File

Function | Arguments | Returns | Optional arguments
-- | -- | -- | --
**fileExists** | filename as Text | YN
**File** | fileName as Text | File | append (=no)
**read** | file as File | Text | lines (=0), bytes (=0)
**read** | | Text | lines (=0), bytes (=0), path (="stdin")
**eof** | file as File | YN
**write** | data as ... | Integer | file (=stdout), eol (=os.eol)

The `write` function is quite special: it is available with all built-in types for the first argument, and also autogenerated for each user-defined type which has the `str` function defined. It is also the standard way to print anything in F+, since leaving out the `file=` argument implies `stdout`.

Files are created on disk when you use the `File` constructor, so call the constructor only when you want this. Otherwise, use the `fileExists` function first to be sure.

How can `read` return binary when needed? (use `binread` or `readBinary`)

Global | Type | Notes
-- | -- | --
stdout | File | Standard output stream
stdin | File | Standard input stream (read-only)
stderr | File | Standard error output stream

Property | Type | Notes
-- | -- | --| --
size [**get**] | Integer |
modified [**get**]|DateTime |
accessed [**get**]|DateTime |
created [**get**]| DateTime |


### Regex

Function | Arguments | Returns | Optional arguments
-- | -- | --| --
_compile | reStr as String | _RegexProg |
match | source as String, regex as _RegexProg | RegexMatch[] |
contains | source as String, regex as _RegexProg | YesOrNo |
replace | source as String, replacement as String, matches as RegexMatch[]| String

Note that _RegexProg is transparent on the F+ side, i.e. you make a match call as follows:
```vb
var source as Text = read("words.dat")
var re as Regex = `([a-z]+)`
var m as RegexMatch = match(source, regex = re)
var repl as Text = replace(source, "_\1_", m)
```

### DateTime
Function | Arguments | Returns | Optional arguments
-- | -- | --| --
**DateTime** | (year, month, day) as Integer | DateTime | (hour, minute, second) as Integer
**add** | base as DateTime, diff as Duration | DateTime
**convert** | base as DateTime, zone as TimeZone | DateTime

Property | Type | Notes| 
-- | -- | --| --
year |Integer | 32-bit signed| 
month |Integer || 
day |Integer || 
hour |Integer || 
minute |Integer || 
second |Integer || 
dayOfWeek [**get**] |Integer (**GET**) || 
dayOfYear [**get**] |Integer (**GET**) || 
zone | Integer/TimeZone? | -24 to +24 (30min increments from UTC)| 
isDST |YN || 
unixTime  [**get**]|Integer (**GET**) | Seconds since epoch| 
monthName|String (**GET**) | locale-dependent month name. you can take substrings if you want short names e.g. `monthName[1:3]` or `monthName[1]` | 
weekOfYear|Integer | | 
| | | 
| | | 
| | | 
| | | 
| | | 
| | | 



### TimeZone

Function | Arguments | Returns | Optional arguments
-- | -- | --| --
**TimeZone** | label as Text | TimeZone
**add** | zone as TimeZone, offset as Integer | TimeZone

Property | Type | Notes
-- | -- | --| --
name | Text |
abbrev | Text |
repr | Text |  e.g. +0530 or -0600

### Duration


### Colour


### Resource?

###Random Numbers

Optional arg for all functions: `gen`

```swift
gen as RandomGenerator = {
  .mersenneTwister,
  .superRNG,
  .blahRNG,
  .garbage
}
```



| Function       | Arguments                         | Returns  | Notes                                                        |
| -------------- | --------------------------------- | -------- | ------------------------------------------------------------ |
| **random**     | array as T[]                      | T        | This appears templated, but under the hood it has only 4 defs: for `void*`, `int`, `short`, `char`. This might be extended to `B16`, `B32` later for dealing with larger value types. |
| **random**     | range as Range                    | Number   | Specify the step of the range if you only want integral values (`1:1:100` gives you integers, `1:100` gives you reals) |
| **randomSeed** | seed as Number                    | -        | Seeds the random generator.                                  |
| **random**     | range as Range, shape as Number[] | Number[] | Returns an array of given shape filled with randoms in the given range. Specify the step if you want only ints (see above). |
| **random**     | array as T[], shape as Number[]   | T[]      | Returns an array of given shape of type T filled with elements of `array` picked at random. |
|                |                                   |          |                                                              |

â€‹	

